# Implementation Plan

## Scope Classification

- Classification: `Small`
- Reasoning: one Linux installer defect blocks runtime bootstrap; expected code delta is focused and non-architectural.
- Workflow Depth:
  - `Small` -> draft implementation plan (solution sketch) -> future-state runtime call stack -> runtime call stack review -> finalize implementation plan -> progress tracking

## Upstream Artifacts (Required)

- Investigation notes: `tickets/in-progress/tts-mcp-linux-speak-enable/investigation-notes.md`
- Requirements: `tickets/in-progress/tts-mcp-linux-speak-enable/requirements.md`
  - Current Status: `Design-ready`
- Runtime call stacks: `tickets/in-progress/tts-mcp-linux-speak-enable/future-state-runtime-call-stack.md`
- Runtime review: `tickets/in-progress/tts-mcp-linux-speak-enable/future-state-runtime-call-stack-review.md`
- Proposed design (required for `Medium/Large`): `N/A (Small scope)`

## Plan Maturity

- Current Status: `Ready For Implementation`
- Notes: Runtime call stack review reached `Go Confirmed` with two consecutive clean rounds.

## Preconditions (Must Be True Before Finalizing This Plan)

- `requirements.md` is at least `Design-ready` (`Refined` allowed): `Yes`
- Runtime call stack review artifact exists and is current: `Yes`
- All in-scope use cases reviewed: `Yes`
- No unresolved blocking findings: `Yes`
- Runtime review has `Go Confirmed` with two consecutive clean deep-review rounds: `Yes`

## Solution Sketch (Required For `Small`, Optional Otherwise)

- Use Cases In Scope:
  - `UC-001` Linux installer resolves valid Python executable and performs release lookup/install.
  - `UC-002` Linux `speak` flow generates valid WAV output via `llama_cpp` backend.
- Touched Files/Modules:
  - `tts-mcp/scripts/install_llama_tts_linux.sh` (`Modify`)
  - `tts-mcp/tests/test_linux_installer.py` (`Add`)
  - `tts-mcp/README.md` (`Modify`, if environment detail needs sync)
- API/Behavior Delta:
  - Installer resolves Python binary robustly (`python3` preferred fallback to `python`), with explicit failure message when neither exists.
- Key Assumptions:
  - Ubuntu host provides `python3`.
  - Runtime download endpoints remain reachable.
- Known Risks:
  - Upstream release asset naming can change.

## Runtime Call Stack Review Gate Summary (Required)

| Round | Review Result | Findings Requiring Write-Back | Write-Back Completed | Round State (`Reset`/`Candidate Go`/`Go Confirmed`) | Clean Streak After Round |
| --- | --- | --- | --- | --- | --- |
| 1 | Pass | No | N/A | Candidate Go | 1 |
| 2 | Pass | No | N/A | Go Confirmed | 2 |

## Go / No-Go Decision

- Decision: `Go`
- Evidence:
  - Final review round: `2`
  - Clean streak at final round: `2`
  - Final review gate line (`Implementation can start`): `Yes`

## Principles

- Bottom-up: patch installer first, then test coverage, then run integration checks.
- Test-driven: add focused tests for Linux Python resolution behavior.
- Mandatory modernization rule: no legacy fallback branches beyond explicit Python executable detection order.

## Dependency And Sequencing Map

| Order | File/Module | Depends On | Why This Order |
| --- | --- | --- | --- |
| 1 | `tts-mcp/scripts/install_llama_tts_linux.sh` | N/A | Primary blocker for Linux runtime bootstrap |
| 2 | `tts-mcp/tests/test_linux_installer.py` | installer behavior | Lock regression coverage for fallback logic |
| 3 | runtime execution checks | installer + tests | Validate real host behavior and final `speak` output |

## Requirement And Design Traceability

| Requirement | Design Section | Use Case / Call Stack | Planned Task ID(s) | Verification |
| --- | --- | --- | --- | --- |
| R-001 installer works without `python` alias | Solution Sketch | UC-001 | T-001, T-002 | unit + real installer run |
| R-002 Linux speak outputs valid WAV | Solution Sketch | UC-002 | T-003 | real run_speak and output validation |

## Step-By-Step Plan

1. Update Linux installer script to resolve Python executable robustly.
2. Add unit test(s) for executable resolution function.
3. Run unit tests.
4. Run Linux installer on this host.
5. Run real Linux speech generation (`run_speak`) and verify WAV output.
6. Sync docs and finalize plan/progress artifacts.

## Per-File Definition Of Done

| File | Implementation Done Criteria | Unit Test Criteria | Integration Test Criteria | E2E Criteria | Notes |
| --- | --- | --- | --- | --- | --- |
| `tts-mcp/scripts/install_llama_tts_linux.sh` | installer can run on Ubuntu without `python` alias | covered by new test file | validated by real installer execution | N/A | shell logic only |
| `tts-mcp/tests/test_linux_installer.py` | test validates resolution order and failure path | passes locally | N/A | N/A | unit scope |
| Runtime output artifact | valid WAV generated by `run_speak` | N/A | real backend invocation returns `ok=true` | tool-level real MCP optional | use local output file |

## Test Strategy

- Unit tests: `uv run python -m pytest`
- Integration tests: real installer run and real `run_speak` invocation on this host
- E2E feasibility: `No`
- If E2E is not feasible, concrete reason and current constraints:
  - Full MCP client/server playback E2E is optional for this fix; behavior-critical path is runtime install + generation path.
- Best-available non-E2E verification evidence when E2E is not feasible:
  - Real Linux installer execution and real `run_speak` output file verification.
- Residual risk notes:
  - MCP transport layer not revalidated in this ticket.
